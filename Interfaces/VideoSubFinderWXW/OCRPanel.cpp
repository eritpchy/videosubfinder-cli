                              //OCRPanel.cpp//                                
//////////////////////////////////////////////////////////////////////////////////
//																				//
// Author:  Simeon Kosnitsky													//
//          skosnits@gmail.com													//
//																				//
// License:																		//
//     This software is released into the public domain.  You are free to use	//
//     it in any way you like, except that you may not sell this source code.	//
//																				//
//     This software is provided "as is" with no expressed or implied warranty.	//
//     I accept no liability for any damage or loss of business that this		//
//     software may cause.														//
//																				//
//////////////////////////////////////////////////////////////////////////////////

#include "OCRPanel.h"
#include "CommonFunctions.h"
#include <algorithm>
#include <vector>
#include <regex>
#include <fstream>
#include <streambuf>
#include <ppl.h>
#include <ppltasks.h>
#include <concurrent_queue.h>
using namespace std;

bool g_use_ISA_images_for_get_txt_area = true;
bool g_use_ILA_images_for_get_txt_area = true;

bool g_join_subs_and_correct_time = true;
bool g_clear_txt_folders = true;

int g_IsCreateClearedTextImages = 0;
int g_RunCreateClearedTextImages = 0;
bool g_ValidateAndCompareTXTImages = false;
bool g_DontDeleteUnrecognizedImages1 = true;
bool g_DontDeleteUnrecognizedImages2 = true;

wxString g_DefStringForEmptySub = "sub duration: %sub_duration%";

bool g_CLEAN_RGB_IMAGES = false;

int  g_ocr_threads = 8;

AssTXTLine::AssTXTLine()
{
	m_TXTStr = string("");
	m_LH = 0;
	m_LY = 0;
	m_LXB = 0;
	m_LXE = 0;
	m_LYB = 0;
	m_LYE = 0;

	m_mY = 0;
	m_mI = 0;
	m_mQ = 0;

	m_BT = 0;
	m_ET = 0;

	m_pAssStyle = NULL;

	m_dX = -1;
	m_dY = -1;
	m_Alignment = -1;
}

AssTXTLine& AssTXTLine::operator=(const AssTXTLine &other)
{
	m_TXTStr = other.m_TXTStr;
	m_LH = other.m_LH;
	m_LY = other.m_LY;
	m_LXB = other.m_LXB;
	m_LXE = other.m_LXE;
	m_LYB = other.m_LYB;
	m_LYE = other.m_LYE;

	m_mY = other.m_mY;
	m_mI = other.m_mI;
	m_mQ = other.m_mQ;

	m_BT = other.m_BT;
	m_ET = other.m_ET;

	m_pAssStyle = other.m_pAssStyle;

	m_dX = other.m_dX;
	m_dY = other.m_dY;
	m_Alignment = other.m_Alignment;

	return *this;
}

AssTXTStyle::AssTXTStyle()
{	
	m_data.clear();

	m_minY = 0;
	m_minI = 0;
	m_minQ = 0;
	
	m_maxY = 0;
	m_maxI = 0;
	m_maxQ = 0;

	m_mY = 0;
	m_mI = 0;
	m_mQ = 0;

	m_minLH = 0;
	m_maxLH = 0;

	m_LH = 0;

	m_Alignment = 2;
	m_MarginL = 10;
	m_MarginR = 10;
	m_MarginV = 10;

	m_Name = string("");
}

// W - full image include scale (if is) width
// H - full image include scale (if is) height
void AssTXTStyle::Compute(int W, int H)
{
	int i;
	int size, val1, val2, val3, val4;

	val1 = 0;
	val2 = 0;
	val3 = 0;
	val4 = 0;

	size = (int)m_data.size();

	for (i=0; i<size; i++)
	{
		val1 += m_data[i].m_mY;
		val2 += m_data[i].m_mI;
		val3 += m_data[i].m_mQ;
		val4 += m_data[i].m_LH;
	}
	

	m_mY = val1/size;
	m_mI = val2/size;
	m_mQ = val3/size;
	m_LH = (val4*528*100)/(size*H*53);
	m_LH += m_LH%2;
}

wxString AssSubHead =
"[Script Info]\n\
; Script generated by VideoSubFinder\n\
; http://www.aegisub.org/\n\
Title: Default Aegisub file\n\
ScriptType: v4.00+\n\
WrapStyle: 0\n\
ScaledBorderAndShadow: yes\n\
YCbCr Matrix: None\n\
\n\
[Aegisub Project Garbage]\n\
\n\
[V4+ Styles]\n\
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n\
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1\n\
\n\
[Events]\n\
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n";

BEGIN_EVENT_TABLE(COCRPanel, wxPanel)
	EVT_BUTTON(ID_BTN_CES, COCRPanel::OnBnClickedCreateEmptySub)
	EVT_BUTTON(ID_BTN_CSCTI, COCRPanel::OnBnClickedCreateSubFromClearedTXTImages)
	EVT_BUTTON(ID_BTN_CSTXT, COCRPanel::OnBnClickedCreateSubFromTXTResults)
	EVT_BUTTON(ID_BTN_CCTI, COCRPanel::OnBnClickedCreateClearedTextImages)
END_EVENT_TABLE()

COCRPanel::COCRPanel(CSSOWnd* pParent)
		:wxPanel( pParent, wxID_ANY )
{
	m_pParent = pParent;
	m_pMF = pParent->m_pMF;
}

COCRPanel::~COCRPanel()
{
}

void COCRPanel::Init()
{
	m_CL1 = wxColour(255, 215, 0);
	m_CLOCR = wxColour(170, 170, 170);

	//"Times New Roman"
	m_BTNFont = wxFont(m_pMF->m_cfg.m_fount_size_ocr_btn, wxFONTFAMILY_SWISS, wxFONTSTYLE_NORMAL,
                    wxFONTWEIGHT_BOLD, false /* !underlined */,
                    wxEmptyString /* facename */, wxFONTENCODING_DEFAULT);

	//"Microsoft Sans Serif"
	m_LBLFont = wxFont(m_pMF->m_cfg.m_fount_size_ocr_lbl, wxFONTFAMILY_DEFAULT, wxFONTSTYLE_NORMAL,
                    wxFONTWEIGHT_NORMAL, false /* !underlined */,
                    wxEmptyString /* facename */, wxFONTENCODING_DEFAULT);


	wxRect rcCCTI, rcCES, rcP3, rcClP3, rlMSD, reMSD, rlJSACT, rlCTXTF, rlSESS, rlSSI, rcTEST, rcCSCTI, rcCSTXT;
	int w, w2, h, dw, dh, txt_dw = m_pMF->m_cfg.m_txt_dw, txt_dy = m_pMF->m_cfg.m_txt_dy;

	wxClientDC dc(this);
	dc.SetFont(m_BTNFont);
	wxSize min_ocr_btn_size = get_max_wxSize({ dc.GetTextExtent(m_pMF->m_cfg.m_ocr_button_ces_text),
									dc.GetTextExtent(m_pMF->m_cfg.m_ocr_button_ccti_text),
									dc.GetTextExtent(m_pMF->m_cfg.m_ocr_button_csftr_text),
									dc.GetTextExtent(m_pMF->m_cfg.m_ocr_button_cesfcti_text) });
	w2 = 700;
	w = min_ocr_btn_size.x + txt_dw*2;
	h = min_ocr_btn_size.y + txt_dy*2;

	rcCCTI.x = w2/2 - w/2;
	rcCCTI.y = 20;
	rcCCTI.width = w;
	rcCCTI.height = h;

	rcCSTXT.x = rcCCTI.x;
	rcCSTXT.y = rcCCTI.GetBottom() + 10;
	rcCSTXT.width = w;
	rcCSTXT.height = h;

	rcCSCTI.x = rcCCTI.x;
	rcCSCTI.y = rcCSTXT.GetBottom() + 10;
	rcCSCTI.width = w;
	rcCSCTI.height = h;

	rcCES.x = rcCCTI.x;
	rcCES.y = rcCSCTI.GetBottom() + 10;
	rcCES.width = w;
	rcCES.height = h;

	rcTEST.x = rcCCTI.GetRight() + 30;
	rcTEST.y = rcCCTI.GetBottom() + 5 - h/2;
	rcTEST.width = 100;
	rcTEST.height = h;

	rlMSD.x = 10;
	rlMSD.y = 20;
	rlMSD.width = rcCCTI.GetLeft() - rlMSD.x*2;
	rlMSD.height = 18;

	int cb_dist = 6;

	reMSD.x = rlMSD.x;
	reMSD.y = rlMSD.GetBottom() + cb_dist;
	reMSD.width = rlMSD.width;
	reMSD.height = 18;

	rlJSACT.x = reMSD.x;
	rlJSACT.y = reMSD.GetBottom() + cb_dist;
	rlJSACT.width = reMSD.width;
	rlJSACT.height = 18;

	rlCTXTF.x = rlJSACT.x;
	rlCTXTF.y = rlJSACT.GetBottom() + cb_dist;
	rlCTXTF.width = rlJSACT.width;
	rlCTXTF.height = 18;

	rlSESS.x = rlCTXTF.x;
	rlSESS.y = rlCTXTF.GetBottom() + cb_dist;
	rlSESS.width = rlCTXTF.width;
	rlSESS.height = 18;
	
	rlSSI.x = rlSESS.x;
	rlSSI.y = rlSESS.GetBottom() + cb_dist;
	rlSSI.width = rlSESS.width;
	rlSSI.height = 18;

	rcP3 = this->GetRect();

	this->GetClientSize(&w, &h);
	rcClP3.x = rcClP3.y = 0; 
	rcClP3.width = w;
	rcClP3.height = h;

	dw = rcP3.width - rcClP3.width;
	dh = rcP3.height - rcClP3.height;

	rcP3.x = 10;	
	rcP3.y = 10;
	rcP3.width = w2 + dw;
	rcP3.height = rcCES.GetBottom() + 20 + dh;

	this->SetSize(rcP3);	

	m_pP3 = new wxPanel( this, wxID_ANY, rcP3.GetPosition(), rcP3.GetSize() );
	m_pP3->SetMinSize(rcP3.GetSize());
	m_pP3->SetBackgroundColour( m_CLOCR );

	m_plblMSD = new wxStaticText( m_pP3, wxID_ANY,
		m_pMF->m_cfg.m_ocr_label_msd_text, rlMSD.GetPosition(), rlMSD.GetSize(), wxALIGN_LEFT | wxST_NO_AUTORESIZE | wxBORDER);
	m_plblMSD->SetFont(m_LBLFont);
	m_plblMSD->SetBackgroundColour( m_CL1 );

	m_pMSD = new wxTextCtrl( m_pP3, wxID_ANY,
		wxString::Format(wxT("%f"), m_pMF->m_cfg.m_ocr_min_sub_duration), reMSD.GetPosition(), reMSD.GetSize());
	m_pMSD->SetFont(m_LBLFont);

	m_pcbJSACT = new CCheckBox(m_pP3, wxID_ANY, &g_join_subs_and_correct_time,
		m_pMF->m_cfg.m_ocr_label_jsact_text, rlJSACT.GetPosition(), rlJSACT.GetSize(), wxALIGN_RIGHT | wxST_NO_AUTORESIZE | wxBORDER);
	m_pcbJSACT->SetFont(m_LBLFont);
	m_pcbJSACT->SetBackgroundColour(m_CL1);

	m_pcbCTXTF = new CCheckBox(m_pP3, wxID_ANY, &g_clear_txt_folders,
		m_pMF->m_cfg.m_ocr_label_clear_txt_folders, rlCTXTF.GetPosition(), rlCTXTF.GetSize(), wxALIGN_RIGHT | wxST_NO_AUTORESIZE | wxBORDER);
	m_pcbCTXTF->SetFont(m_LBLFont);
	m_pcbCTXTF->SetBackgroundColour(m_CL1);

	m_pcbSESS = new CCheckBox(m_pP3, wxID_ANY, &g_save_each_substring_separately,
		m_pMF->m_cfg.m_ocr_label_save_each_substring_separately, rlSESS.GetPosition(), rlSESS.GetSize(), wxALIGN_RIGHT | wxST_NO_AUTORESIZE | wxBORDER);
	m_pcbSESS->SetFont(m_LBLFont);
	m_pcbSESS->SetBackgroundColour(m_CL1);

	m_pcbSSI = new CCheckBox(m_pP3, wxID_ANY, &g_save_scaled_images,
		m_pMF->m_cfg.m_ocr_label_save_scaled_images, rlSSI.GetPosition(), rlSSI.GetSize(), wxALIGN_RIGHT | wxST_NO_AUTORESIZE | wxBORDER);
	m_pcbSSI->SetFont(m_LBLFont);
	m_pcbSSI->SetBackgroundColour(m_CL1);

	m_pCES = new wxButton( m_pP3, ID_BTN_CES,
		m_pMF->m_cfg.m_ocr_button_ces_text, rcCES.GetPosition(), rcCES.GetSize());
	m_pCES->SetFont(m_BTNFont);

	m_pCCTI = new wxButton( m_pP3, ID_BTN_CCTI,
		m_pMF->m_cfg.m_ocr_button_ccti_text, rcCCTI.GetPosition(), rcCCTI.GetSize());
	m_pCCTI->SetFont(m_BTNFont);

	m_pCSTXT = new wxButton( m_pP3, ID_BTN_CSTXT,
		m_pMF->m_cfg.m_ocr_button_csftr_text, rcCSTXT.GetPosition(), rcCSTXT.GetSize());
	m_pCSTXT->SetFont(m_BTNFont);

	m_pCSCTI = new wxButton( m_pP3, ID_BTN_CSCTI,
		m_pMF->m_cfg.m_ocr_button_cesfcti_text, rcCSCTI.GetPosition(), rcCSCTI.GetSize());
	m_pCSCTI->SetFont(m_BTNFont);

	wxBoxSizer *top_sizer = new wxBoxSizer( wxVERTICAL );

	wxBoxSizer *button_sizer = new wxBoxSizer( wxHORIZONTAL );

	button_sizer->Add(m_pP3, 1, wxALIGN_CENTER, 0 );

	top_sizer->Add(button_sizer, 1, wxALIGN_CENTER );

	this->SetSizer(top_sizer);
}

void COCRPanel::OnBnClickedCreateEmptySub(wxCommandEvent& event)
{
	wxString Str, SubStr, hour1, hour2, min1, min2, sec1, sec2, msec1, msec2;
	int i, j, k, sec, msec;
	fstream fout;
	u64 bt, et, dt, mdt;
	char str[30];

	wxDir dir(g_work_dir + "/RGBImages");
	vector<wxString> FileNamesVector;
	vector<u64> BT, ET;
	wxString filename;
	bool res;

	res = dir.GetFirst(&filename);
    while ( res )
    {
		FileNamesVector.push_back(filename);

        res = dir.GetNext(&filename);
    }
	
	for (i=0; i<(int)FileNamesVector.size()-1; i++)
	for (j=i+1; j<(int)FileNamesVector.size(); j++)
	{
		if (FileNamesVector[i] > FileNamesVector[j])
		{
			Str = FileNamesVector[i];
			FileNamesVector[i] = FileNamesVector[j];
			FileNamesVector[j] = Str;
		}
	}	

	Str = m_pMSD->GetValue();
	mdt = (s64)atof(Str)*1000;

	for(k=0; k<(int)FileNamesVector.size(); k++)
	{
		Str = FileNamesVector[k];

		hour1 = Str.Mid(0,1);
		min1 = Str.Mid(2,2);
		sec1 = Str.Mid(5,2);
		msec1 = Str.Mid(8,3);

		hour2 = Str.Mid(13,1);
		min2 = Str.Mid(15,2);
		sec2 = Str.Mid(18,2);
		msec2 = Str.Mid(21,3);

		bt = (atoi(hour1)*3600 + atoi(min1)*60 + atoi(sec1))*1000 + atoi(msec1);
		et = (atoi(hour2)*3600 + atoi(min2)*60 + atoi(sec2))*1000 + atoi(msec2);

		BT.push_back(bt);
		ET.push_back(et);
	}

	if (g_join_subs_and_correct_time)
	{
		for (k = 0; k < (int)FileNamesVector.size() - 1; k++)
		{
			if (ET[k] - BT[k] < mdt)
			{
				if (BT[k] + mdt < BT[k + 1])
				{
					ET[k] = BT[k] + mdt;
				}
				else
				{
					ET[k] = BT[k + 1] - 1;
				}
			}
		}
	}

	fout.open(string(g_work_dir + string("/sub.srt")).c_str(), ios::out);
	for(k=0; k<(int)FileNamesVector.size(); k++)
	{
		bt = BT[k];
		et = ET[k];

		Str = VideoTimeToStr2(bt)+
			  " --> "+
			  VideoTimeToStr2(et);

		dt = et - bt;
		sec = (int)(dt/1000);
		msec = (int)(dt%1000);
		
		_itoa(sec, str, 10);
		sec1 = str;

		_itoa(msec, str, 10);
		if (msec < 10) msec1 = wxString("00")+str; 
		else
		{
			if (msec < 100) msec1 = wxString("0")+str; 
			else msec1 = str; 
		}

		SubStr = g_DefStringForEmptySub;

		if (g_DefStringForEmptySub.Contains("%sub_duration%"))
		{			
			SubStr.Replace("%sub_duration%", sec1 + "," + msec1);
		}

		fout << (k+1) << "\n" << Str << "\n" << SubStr << "\n\n";
	}
	fout.close();

	fout.open(string(g_work_dir + "/sub.ass").c_str(), ios::out);
	fout << AssSubHead;
	for (k = 0; k < (int)FileNamesVector.size(); k++)
	{
		bt = BT[k];
		et = ET[k];

		dt = et - bt;
		sec = (int)(dt / 1000);
		msec = (int)(dt % 1000);

		_itoa(sec, str, 10);
		sec1 = str;

		_itoa(msec, str, 10);
		if (msec < 10) msec1 = wxString("00") + str;
		else
		{
			if (msec < 100) msec1 = wxString("0") + str;
			else msec1 = str;
		}

		SubStr = g_DefStringForEmptySub;

		if (g_DefStringForEmptySub.Contains("%sub_duration%"))
		{
			SubStr.Replace("%sub_duration%", sec1 + "," + msec1);
		}

		fout << "Dialogue: 0," + VideoTimeToStr3(bt) + "," + VideoTimeToStr3(et) + ",Default,,0,0,0,," + SubStr + "\n";
	}
	fout.close();
}

void COCRPanel::OnBnClickedCreateSubFromTXTResults(wxCommandEvent& event)
{
	CreateSubFromTXTResults();
}

void COCRPanel::OnBnClickedCreateSubFromClearedTXTImages(wxCommandEvent& event)
{
	wxString Str, SubStr, Name, hour1, hour2, min1, min2, sec1, sec2, msec1, msec2;
	int i, j, k, kb, sec, msec;
	fstream fout;
	char str[30];
	u64 bt, et, dt, mdt;

	wxString dir_path = wxString(g_work_dir + string("/TXTImages/"));
	wxDir dir(dir_path);
	vector<wxString> FileNamesVector;
	vector<u64> BT, ET;
	wxString filename;
	bool res;

	res = dir.GetFirst(&filename);
    while ( res )
    {
		FileNamesVector.push_back(filename);

        res = dir.GetNext(&filename);
    }

	for (i=0; i<(int)FileNamesVector.size()-1; i++)
	for (j=i+1; j<(int)FileNamesVector.size(); j++)
	{
		if (FileNamesVector[i] > FileNamesVector[j])
		{
			Str = FileNamesVector[i];
			FileNamesVector[i] = FileNamesVector[j];
			FileNamesVector[j] = Str;
		}
	}

	Str = m_pMSD->GetValue();
	mdt = (s64)atof(Str)*1000;

	k = 0;
	while (k < (int)FileNamesVector.size())
	{
		kb = k;
		i = 0;

		if (g_join_subs_and_correct_time)
		{
			while ((k < (int)FileNamesVector.size()) &&
				(FileNamesVector[kb].Mid(0, 11) == FileNamesVector[k].Mid(0, 11))
				)
			{
				k++;
			}
		}
		else
		{
			k++;
		}

		Str = FileNamesVector[kb];

		hour1 = Str.Mid(0,1);
		min1 = Str.Mid(2,2);
		sec1 = Str.Mid(5,2);
		msec1 = Str.Mid(8,3);

		hour2 = Str.Mid(13,1);
		min2 = Str.Mid(15,2);
		sec2 = Str.Mid(18,2);
		msec2 = Str.Mid(21,3);

		bt = (atoi(hour1)*3600 + atoi(min1)*60 + atoi(sec1))*1000 + atoi(msec1);
		et = (atoi(hour2)*3600 + atoi(min2)*60 + atoi(sec2))*1000 + atoi(msec2);

		BT.push_back(bt);
		ET.push_back(et);
	}

	if (g_join_subs_and_correct_time)
	{
		for (k = 0; k < (int)BT.size() - 1; k++)
		{
			if (ET[k] - BT[k] < mdt)
			{
				if (BT[k] + mdt < BT[k + 1])
				{
					ET[k] = BT[k] + mdt;
				}
				else
				{
					ET[k] = BT[k + 1] - 1;
				}
			}
		}
	}

	fout.open(string(g_work_dir + "/sub.srt").c_str(), ios::out);
	for(k=0; k<(int)BT.size(); k++)
	{
		bt = BT[k];
		et = ET[k];

		Str = VideoTimeToStr2(bt)+
			  " --> "+
			  VideoTimeToStr2(et);

		dt = et - bt;
		sec = (int)(dt/1000);
		msec = (int)(dt%1000);
		
		_itoa(sec, str, 10);
		sec1 = str;

		_itoa(msec, str, 10);
		if (msec < 10) msec1 = wxString("00")+str; 
		else
		{
			if (msec < 100) msec1 = wxString("0")+str; 
			else msec1 = str; 
		}

		SubStr = g_DefStringForEmptySub;

		if (g_DefStringForEmptySub.Contains("%sub_duration%"))
		{			
			SubStr.Replace("%sub_duration%", sec1 + "," + msec1);
		}

		fout << (k+1) << "\n" << Str << "\n" << SubStr << "\n\n";
	}
	fout.close();

	fout.open(string(g_work_dir + "/sub.ass").c_str(), ios::out);
	fout << AssSubHead;
	for (k = 0; k < (int)BT.size(); k++)
	{
		bt = BT[k];
		et = ET[k];

		dt = et - bt;
		sec = (int)(dt / 1000);
		msec = (int)(dt % 1000);

		_itoa(sec, str, 10);
		sec1 = str;

		_itoa(msec, str, 10);
		if (msec < 10) msec1 = wxString("00") + str;
		else
		{
			if (msec < 100) msec1 = wxString("0") + str;
			else msec1 = str;
		}

		SubStr = g_DefStringForEmptySub;

		if (g_DefStringForEmptySub.Contains("%sub_duration%"))
		{
			SubStr.Replace("%sub_duration%", sec1 + "," + msec1);
		}

		fout << "Dialogue: 0," + VideoTimeToStr3(bt) + "," + VideoTimeToStr3(et) + ",Default,,0,0,0,," + SubStr + "\n";
	}
	fout.close();
}

void COCRPanel::CreateSubFromTXTResults()
{
	wxString Str, Name, hour1, hour2, min1, min2, sec1, sec2, msec1, msec2;
	int i, j, k, kb, sec, msec, max_mY_dif, max_mI_dif, max_mQ_dif, max_posY_dif;
	int val1, val2, val3, val4, val5, val6, val7, val8;
	string fname, image_name;
	fstream fout/*, txt_info*/;
	u64 bt, et, dt, mdt;
	double max_LH_dif;
	int bln;

	vector<wxString> FileNamesVector;
	vector<wxString> TXTVector;
	vector<u64> BT, ET;

	//AssTXTLine *AssTXTVector;
	//AssTXTStyle *AssTXTStyleVector; 	
	//AssTXTLine AssLine;
	//AssTXTStyle AssStyle;
	//YIQ_LH_Struct AssStyleDatum;
	//int mR, mG, mB, NT, NS;
	//string BaseStyleName;
	//BaseStyleName = string("Base");
	//max_mY_dif = 16;
	//max_mI_dif = 10;
	//max_mQ_dif = 10;
	//max_posY_dif = 5;
	//max_LH_dif = 0.20;

	wxString dir_path = wxString(g_work_dir + string("/TXTResults/"));
	wxDir dir(dir_path);
	wxString filename;
	bool res;

	res = dir.GetFirst(&filename, "*.txt");
    while ( res )
    {
		FileNamesVector.push_back(filename);

        res = dir.GetNext(&filename);
    }

	if (FileNamesVector.size() == 0) return;

	for (i=0; i<(int)FileNamesVector.size()-1; i++)
	for (j=i+1; j<(int)FileNamesVector.size(); j++)
	{
		if (FileNamesVector[i] > FileNamesVector[j])
		{
			Str = FileNamesVector[i];
			FileNamesVector[i] = FileNamesVector[j];
			FileNamesVector[j] = Str;
		}
	}

	Str = m_pMSD->GetValue();
	mdt = (s64)atof(Str)*1000;

	//str[0] = '\0';

	//fname = g_work_dir + string("/text_lines.info");
	//txt_info.open(fname.c_str(), ios::in);

/*	NT = 0;
	AssTXTVector = new AssTXTLine[(int)FileNamesVector.size()];

	NS = 0;
	AssTXTStyleVector = new AssTXTStyle[(int)FileNamesVector.size()];*/	
	
    //--------------

	int W, H;

    //--------------
    
	k = 0;
	while (k < (int)FileNamesVector.size())
	{
		kb = k;

		Str = FileNamesVector[kb];

		hour1 = Str.Mid(0,1);
		min1 = Str.Mid(2,2);
		sec1 = Str.Mid(5,2);
		msec1 = Str.Mid(8,3);

		hour2 = Str.Mid(13,1);
		min2 = Str.Mid(15,2);
		sec2 = Str.Mid(18,2);
		msec2 = Str.Mid(21,3);

		bt = (atoi(hour1)*3600 + atoi(min1)*60 + atoi(sec1))*1000 + atoi(msec1);
		et = (atoi(hour2)*3600 + atoi(min2)*60 + atoi(sec2))*1000 + atoi(msec2);

		BT.push_back(bt);
		ET.push_back(et);

		Str = "";
		i = 0;
		while( (k < (int)FileNamesVector.size()) &&
			   (FileNamesVector[kb].Mid(0, 11) == FileNamesVector[k].Mid(0, 11))
			 )
		{
			Name = g_work_dir + "/TXTResults/"+FileNamesVector[k];

			std::ifstream fin(Name.ToStdString());
			std::string str((std::istreambuf_iterator<char>(fin)),
							std::istreambuf_iterator<char>());
			fin.close();
			if (str.size() > 0)
			{
				if (i > 0) Str += "\n";
				Str += str;
				i++;
			}			

			//AssLine.m_TXTStr = string(str);
			//AssLine.m_BT = bt;
			//AssLine.m_ET = et;			

			//image_name = string("/TXTImages/") + GetFileName(FileNamesVector[k]) + g_im_save_format;
			//
   //         fname = string("");
			//do
			//{
   //             if ( txt_info.eof() )                
   //             {
   //                 break;
   //             }

			//	txt_info >> fname; // file name
			//	
			//	txt_info >> str; // "="
			//	txt_info >> str; // "YB"
			//	txt_info >> str; // YB value
			//	txt_info >> str; // "LH"
			//	txt_info >>	AssLine.m_LH;
			//	txt_info >> str; // "LY"
			//	txt_info >>	AssLine.m_LY;
			//	txt_info >> str; // "LXB"
			//	txt_info >>	AssLine.m_LXB;
			//	txt_info >> str; // "LXE"
			//	txt_info >>	AssLine.m_LXE;
			//	txt_info >> str; // "LYB"
			//	txt_info >>	AssLine.m_LYB;
			//	txt_info >> str; // "LYE"
			//	txt_info >>	AssLine.m_LYE;
			//	txt_info >> str; // "YIQ"
			//	txt_info >>	AssLine.m_mY;
			//	txt_info >>	AssLine.m_mI;
			//	txt_info >>	AssLine.m_mQ;
			//	txt_info >> str; // "W"
			//	txt_info >> AssLine.m_W;
			//	txt_info >> str; // "H"
			//	txt_info >> AssLine.m_H;
			//}
			//while (fname != image_name);
			//
			//if (fname != image_name)
			//{
			//	txt_info.close();
			//	Str = wxString("There is not info about \"") + wxString(image_name.c_str()) 
   //                 + wxString("\" in \"text_lines.info\" file.\n") 
   //                 + wxString("Please run \"Create Cleared Text Images\" again.");

			//	#ifdef WIN32
			//	::MessageBox(NULL, Str, L"CreateSubFromTXTResults", MB_ICONERROR);			
			//	#endif

			//	return;
			//}

			//AssTXTVector[NT] = AssLine;
			//NT++;

			k++;

			if (!g_join_subs_and_correct_time)
			{
				break;
			}
		}

		TXTVector.push_back(Str);
	}

	//txt_info.close();

	// סמחהאול srt subtitle
	
	k=0;
	while(k < (int)TXTVector.size()-1)
	{
		if (TXTVector[k] == "")
		{
			if (g_DontDeleteUnrecognizedImages2 == false)
			{
				if (g_join_subs_and_correct_time)
				{
					for (i = k; i < (int)TXTVector.size() - 1; i++)
					{
						BT[i] = BT[i + 1];
						ET[i] = ET[i + 1];
						TXTVector[i] = TXTVector[i + 1];
					}
					BT.pop_back();
					ET.pop_back();
					TXTVector.pop_back();

					continue;
				}
			}
			else
			{
				TXTVector[k] = wxString("#unrecognized text#");
			}
		}

		if (g_join_subs_and_correct_time)
		{
			if (BT[k + 1] - ET[k] <= 333)
			{
				if (TXTVector[k + 1] == TXTVector[k])
				{
					ET[k] = ET[k + 1];

					for (i = k + 1; i < (int)TXTVector.size() - 1; i++)
					{
						BT[i] = BT[i + 1];
						ET[i] = ET[i + 1];
						TXTVector[i] = TXTVector[i + 1];
					}
					BT.pop_back();
					ET.pop_back();
					TXTVector.pop_back();

					continue;
				}
			}
		}

		k++;
	}

	if (g_join_subs_and_correct_time)
	{
		for (k = 0; k < (int)TXTVector.size() - 1; k++)
		{
			if (ET[k] - BT[k] < mdt)
			{
				if (BT[k] + mdt < BT[k + 1])
				{
					ET[k] = BT[k] + mdt;
				}
				else
				{
					ET[k] = BT[k + 1] - 1;
				}
			}
		}
	}

	fout.open(string(g_work_dir + "/sub.srt").c_str(), ios::out);

	for(k=0; k<(int)TXTVector.size(); k++)
	{
		bt = BT[k];
		et = ET[k];

		Str = VideoTimeToStr2(bt)+
			  " --> "+
			  VideoTimeToStr2(et);

		fout << (k+1) << "\n" << Str << "\n" << TXTVector[k] << "\n\n";
	}

	fout.close();

	fout.open(string(g_work_dir + "/sub.ass").c_str(), ios::out);	
	fout << AssSubHead;
	for (k = 0; k < (int)TXTVector.size(); k++)
	{
		bt = BT[k];
		et = ET[k];

		//example: Dialogue: 0,0:00:03.29,0:00:05.00,Default,,0,0,0,,Regulars gather up!

		std::string txt = TXTVector[k];
		std::regex re("\\n");
		std::smatch match;
		std::string res;
		txt = std::regex_replace(txt, re, "\\N");

		fout << "Dialogue: 0," + VideoTimeToStr3(bt) + "," + VideoTimeToStr3(et) + ",Default,,0,0,0,," + txt + "\n";
	}
	fout.close();

	//// סמחהאול ass subtitle

	//for(i=0; i < NT; i++)
	//{
	//	if (AssTXTVector[i].m_TXTStr != string(""))
	//	{
	//		if (AssTXTVector[i].m_LYE - AssTXTVector[i].m_LY <= g_dmaxy/4)
	//		{
	//			AssTXTVector[i].m_LYE = max(AssTXTVector[i].m_LYE, AssTXTVector[i].m_LY + (AssTXTVector[i].m_LH*7)/22);
	//		}
	//	}
	//}

	//for(i=0; i < NT-1; i++)
	//{
	//	if (AssTXTVector[i+1].m_BT == AssTXTVector[i].m_BT)
	//	{
	//		val1 = AssTXTVector[i].m_LY - AssTXTVector[i].m_LH/2 - H/2;
	//		val2 = AssTXTVector[i+1].m_LY - AssTXTVector[i+1].m_LH/2 - H/2;

	//		if ( (val1 >= AssTXTVector[i].m_LH/2) &&
	//			 (val2 >= AssTXTVector[i+1].m_LH/2) )
	//		{
	//			AssLine = AssTXTVector[i+1];
	//			AssTXTVector[i+1] = AssTXTVector[i];
	//			AssTXTVector[i] = AssLine;
	//		}
	//	}
	//}

	//k = 0;
	//while(k < NT)
	//{
	//	if (AssTXTVector[k].m_TXTStr == string(""))
	//	{
	//		if (g_DontDeleteUnrecognizedImages2 == false)
	//		{
	//			for(i=k; i<NT-1; i++)
	//			{
	//				AssTXTVector[i] = AssTXTVector[i+1];
	//			}
	//			NT--;

	//			continue;
	//		}
	//		else
	//		{
	//			AssTXTVector[k].m_TXTStr = string("#unrecognized text#");
	//			AssTXTVector[k].m_LH = 14;
	//			AssTXTVector[k].m_mY = 0;
	//			AssTXTVector[k].m_mI = 0;
	//			AssTXTVector[k].m_mQ = 0;
	//			/*AssTXTVector[k].m_LXB = AssTXTVector[k].m_LXE = W/2;
	//			AssTXTVector[k].m_LY = AssTXTVector[k].m_LYE = H - 20;				
	//			AssTXTVector[k].m_LYB = AssTXTVector[k].m_LYE - AssTXTVector[k].m_LH + 1;
	//			*/
	//		}
	//	}

	//	j = k+1;

	//	while ( (j < NT) &&
	//		    (AssTXTVector[j].m_BT-AssTXTVector[k].m_ET <= 333) )
	//	{
	//		if ( (AssTXTVector[j].m_TXTStr == AssTXTVector[k].m_TXTStr) &&				
	//			 (abs(AssTXTVector[j].m_LY - AssTXTVector[k].m_LY) <= max_posY_dif) &&
	//			 (abs(AssTXTVector[j].m_mY - AssTXTVector[k].m_mY) <= max_mY_dif) &&
	//			 (abs(AssTXTVector[j].m_mI - AssTXTVector[k].m_mI) <= max_mI_dif) &&
	//			 (abs(AssTXTVector[j].m_mQ - AssTXTVector[k].m_mQ) <= max_mQ_dif) &&
	//			 ((double)abs(AssTXTVector[j].m_LH - AssTXTVector[k].m_LH)/(double)AssTXTVector[k].m_LH <= max_LH_dif) )
	//		{
	//			AssTXTVector[k].m_ET = AssTXTVector[j].m_ET;

	//			for(i=j; i<NT-1; i++)
	//			{
	//				AssTXTVector[i] = AssTXTVector[i+1];
	//			}
	//			NT--;

	//			continue;
	//		}
	//		else
	//		{
	//			j++;
	//		}
	//	}

	//	k++;
	//}

	//for(k=0; k<NT; k++)
	//{
	//	if (AssTXTVector[k].m_ET-AssTXTVector[k].m_BT < (s64)mdt)
	//	{
	//		AssTXTVector[k].m_ET = AssTXTVector[k].m_BT + mdt;
	//	}
	//}

	//for(i=0; i<NT; i++)
	//{
	//	bln = 0;

	//	for(j=0; j<NS; j++)
	//	{
	//		val1 = AssTXTStyleVector[j].m_minY;
	//		val2 = AssTXTStyleVector[j].m_maxY;

	//		if (AssTXTVector[i].m_mY < val1) val1 = AssTXTVector[i].m_mY;
	//		if (AssTXTVector[i].m_mY > val2) val2 = AssTXTVector[i].m_mY;

	//		val3 = AssTXTStyleVector[j].m_minI;
	//		val4 = AssTXTStyleVector[j].m_maxI;

	//		if (AssTXTVector[i].m_mI < val3) val3 = AssTXTVector[i].m_mI;
	//		if (AssTXTVector[i].m_mI > val4) val4 = AssTXTVector[i].m_mI;

	//		val5 = AssTXTStyleVector[j].m_minQ;
	//		val6 = AssTXTStyleVector[j].m_maxQ;

	//		if (AssTXTVector[i].m_mQ < val5) val5 = AssTXTVector[i].m_mQ;
	//		if (AssTXTVector[i].m_mQ > val6) val6 = AssTXTVector[i].m_mQ;

	//		val7 = AssTXTStyleVector[j].m_minLH;
	//		val8 = AssTXTStyleVector[j].m_maxLH;

	//		if (AssTXTVector[i].m_LH < val7) val7 = AssTXTVector[i].m_LH;
	//		if (AssTXTVector[i].m_LH > val8) val8 = AssTXTVector[i].m_LH;

	//		if ( ((val2 - val1) <= max_mY_dif) &&
	//		     ((val4 - val3) <= max_mI_dif) &&
	//		     ((val6 - val5) <= max_mQ_dif) &&
	//		     ((double)(val8 - val7)/(double)val7 <= max_LH_dif) )
	//		{
	//			bln = 1;

	//			AssTXTStyleVector[j].m_minY = val1;
	//			AssTXTStyleVector[j].m_maxY = val2;

	//			AssTXTStyleVector[j].m_minI = val3;
	//			AssTXTStyleVector[j].m_maxI = val4;

	//			AssTXTStyleVector[j].m_minQ = val5;
	//			AssTXTStyleVector[j].m_maxQ = val6;

	//			AssTXTStyleVector[j].m_minLH = val7;
	//			AssTXTStyleVector[j].m_maxLH = val8;

	//			AssStyleDatum.m_mY = AssTXTVector[i].m_mY;
	//			AssStyleDatum.m_mI = AssTXTVector[i].m_mI;
	//			AssStyleDatum.m_mQ = AssTXTVector[i].m_mQ;
	//			AssStyleDatum.m_LH = AssTXTVector[i].m_LH;

	//			AssTXTStyleVector[j].m_data.push_back(AssStyleDatum);

	//			AssTXTVector[i].m_AssStyleIndex = j;
	//			//AssTXTVector[i].m_pAssStyle = &(AssTXTStyleVector[j]);
	//		}

	//		if (bln == 1)
	//		{
	//			break;
	//		}
	//	}

	//	if (bln == 0)
	//	{
	//		AssStyleDatum.m_mY = AssTXTVector[i].m_mY;
	//		AssStyleDatum.m_mI = AssTXTVector[i].m_mI;
	//		AssStyleDatum.m_mQ = AssTXTVector[i].m_mQ;
	//		AssStyleDatum.m_LH = AssTXTVector[i].m_LH;

	//		AssStyle.m_data.clear();
	//		AssStyle.m_data.push_back(AssStyleDatum);

	//		AssStyle.m_minY = AssStyleDatum.m_mY;
	//		AssStyle.m_maxY = AssStyleDatum.m_mY;

	//		AssStyle.m_minI = AssStyleDatum.m_mI;
	//		AssStyle.m_maxI = AssStyleDatum.m_mI;

	//		AssStyle.m_minQ = AssStyleDatum.m_mQ;
	//		AssStyle.m_maxQ = AssStyleDatum.m_mQ;

	//		AssStyle.m_minLH = AssStyleDatum.m_LH;
	//		AssStyle.m_maxLH = AssStyleDatum.m_LH;

	//		val1 = (AssTXTVector[i].m_LXB + AssTXTVector[i].m_LXE)/2;
	//		val2 = val1 - W/2;

	//		AssStyle.m_Alignment = 2;

	//		if ((double)abs(val2)/(W/2) < 0.3)
	//		{
	//			AssStyle.m_MarginL = -1;
	//			AssStyle.m_MarginR = -1;
	//		}
	//		else
	//		{
	//			if (val2 < 0)
	//			{
	//				val3 = AssTXTVector[i].m_LXB - AssTXTVector[i].m_LH/10;
	//				if (val3 < 0) val3 = 0;
	//				
	//				AssStyle.m_MarginL = val3;
	//				AssStyle.m_MarginR = val3;
	//			}
	//			else
	//			{
	//				val3 = W-(AssTXTVector[i].m_LXE + AssTXTVector[i].m_LH/10);
	//				if (val3 < 0) val3 = 0;

	//				AssStyle.m_MarginL = val3;
	//				AssStyle.m_MarginR = val3;
	//			}
	//		}

	//		val1 = AssTXTVector[i].m_LY - AssTXTVector[i].m_LH/2;
	//		val2 = val1 - H/2;

	//		if (abs(val2) < AssTXTVector[i].m_LH/2)
	//		{
	//			AssStyle.m_Alignment += 3;

	//			AssStyle.m_MarginV = 0;
	//		}
	//		else
	//		{
	//			if (val2 < 0)
	//			{
	//				AssStyle.m_Alignment += 6;

	//				val3 = AssTXTVector[i].m_LYB;

	//				if (val3 > 0)
	//				{
	//					AssStyle.m_MarginV = val3;
	//				}
	//				else
	//				{
	//					AssStyle.m_MarginV = 0;
	//				}
	//			}
	//			else
	//			{
	//				val3 = H - AssTXTVector[i].m_LYE;

	//				if (val3 > 0)
	//				{
	//					AssStyle.m_MarginV = val3;
	//				}
	//				else
	//				{
	//					AssStyle.m_MarginV = 0;
	//				}
	//			}
	//		}

	//		sprintf(str, "%.2d", NS+1);
	//		AssStyle.m_Name = BaseStyleName + string(str);

	//		AssTXTStyleVector[NS] = AssStyle;
	//		NS++;

	//		AssTXTVector[i].m_AssStyleIndex = NS-1;
	//		//AssTXTVector[i].m_pAssStyle = &(AssTXTStyleVector[AssTXTVector[i].m_AssStyleIndex]);
	//	}
	//}
	//
	//for(i=0; i<NS; i++)
	//{
	//	AssTXTStyleVector[i].Compute(W, H);
	//}

	//for(i=0; i<NT; i++)
	//{
	//	AssTXTVector[i].m_pAssStyle = &(AssTXTStyleVector[AssTXTVector[i].m_AssStyleIndex]);
	//}

	//for(i=0; i<NT; i++)
	//{
	//	AssTXTVector[i].m_dX = -1;
	//	AssTXTVector[i].m_dY = -1;
	//	AssTXTVector[i].m_Alignment = -1;

	//	int ho = (AssTXTVector[i].m_pAssStyle->m_Alignment - 1)%3 + 1;
	//	int vo = (AssTXTVector[i].m_pAssStyle->m_Alignment - 1)/3 + 1;

	//	val1 = (AssTXTVector[i].m_LXB + AssTXTVector[i].m_LXE)/2;
	//	val2 = val1 - W/2;

	//	val3 = AssTXTVector[i].m_LXB - AssTXTVector[i].m_LH/10;
	//	if (val3 < 0) val3 = 0;

	//	if (abs(val2) >= AssTXTVector[i].m_LH*2)
	//	{
	//		if (AssTXTVector[i].m_pAssStyle->m_MarginL == -1)
	//		{
	//			AssTXTVector[i].m_pAssStyle->m_MarginL = val3;
	//			AssTXTVector[i].m_pAssStyle->m_MarginR = val3;				
	//		}
	//		
	//		if ( abs(AssTXTVector[i].m_pAssStyle->m_MarginL - val3) < AssTXTVector[i].m_LH/2 )
	//		{
	//			if (val2 < 0)
	//			{
	//				AssTXTVector[i].m_Alignment = 1;
	//			}
	//			else
	//			{
	//				AssTXTVector[i].m_Alignment = 3;
	//			}
	//		}
	//		else
	//		{
	//			val1 = (AssTXTVector[i].m_LXB + AssTXTVector[i].m_LXE)/2;
	//			val2 = AssTXTVector[i].m_LY - AssTXTVector[i].m_LH/2;

	//			AssTXTVector[i].m_Alignment = 5;
	//			AssTXTVector[i].m_dX = val1;
	//			AssTXTVector[i].m_dY = val2;

	//			continue;
	//		}
	//	}

	//	val1 = AssTXTVector[i].m_LY - AssTXTVector[i].m_LH/2;
	//	val2 = val1 - H/2;

	//	if ((double)abs(val2)/(H/2) < 0.05)
	//	{
	//		if (vo != 2)
	//		{
	//			if (AssTXTVector[i].m_Alignment == -1)
	//			{
	//				AssTXTVector[i].m_Alignment = 5;
	//			}
	//			else
	//			{
	//				AssTXTVector[i].m_Alignment += 3;
	//			}
	//		}
	//	}
	//	else
	//	{
	//		if (val2 < 0)
	//		{
	//			val3 = AssTXTVector[i].m_LY - AssTXTVector[i].m_LH - AssTXTVector[i].m_LH/5;

	//			if ( abs(AssTXTVector[i].m_pAssStyle->m_MarginV - val3) < AssTXTVector[i].m_LH/2 )
	//			{
	//				if (vo != 3)
	//				{
	//					if (AssTXTVector[i].m_Alignment == -1)
	//					{
	//						AssTXTVector[i].m_Alignment = 8;
	//					}
	//					else
	//					{
	//						AssTXTVector[i].m_Alignment += 6;
	//					}
	//				}
	//			}
	//			else
	//			{
	//				val1 = (AssTXTVector[i].m_LXB + AssTXTVector[i].m_LXE)/2;
	//				val2 = AssTXTVector[i].m_LY - AssTXTVector[i].m_LH/2;

	//				AssTXTVector[i].m_Alignment = 5;
	//				AssTXTVector[i].m_dX = val1;
	//				AssTXTVector[i].m_dY = val2;

	//				continue;
	//			}
	//		}
	//		else
	//		{
	//			val3 = (H - (AssTXTVector[i].m_LY + AssTXTVector[i].m_LH/10));

	//			if ( abs(AssTXTVector[i].m_pAssStyle->m_MarginV - val3) < AssTXTVector[i].m_LH/2 )
	//			{
	//				if (vo != 1)
	//				{
	//					if (AssTXTVector[i].m_Alignment == -1)
	//					{
	//						AssTXTVector[i].m_Alignment = 2;
	//					}
	//				}
	//			}
	//			else
	//			{
	//				val1 = (AssTXTVector[i].m_LXB + AssTXTVector[i].m_LXE)/2;
	//				val2 = AssTXTVector[i].m_LY - AssTXTVector[i].m_LH/2;

	//				AssTXTVector[i].m_Alignment = 5;
	//				AssTXTVector[i].m_dX = val1;
	//				AssTXTVector[i].m_dY = val2;

	//				continue;
	//			}
	//		}
	//	}
	//}

	//// מבתוהטםול מבתוהטםולו סאב
	//i=0;
	//while(i<NT-1)
	//{
	//	if( (AssTXTVector[i+1].m_AssStyleIndex == AssTXTVector[i].m_AssStyleIndex) &&
	//		(AssTXTVector[i+1].m_BT == AssTXTVector[i].m_BT) &&
	//		(AssTXTVector[i+1].m_ET == AssTXTVector[i].m_ET) )
	//	{
	//		val1 = abs((AssTXTVector[i+1].m_LXB + AssTXTVector[i+1].m_LXE) - (AssTXTVector[i].m_LXB + AssTXTVector[i].m_LXE))/2;
	//		val2 = abs((AssTXTVector[i+1].m_LYB + AssTXTVector[i+1].m_LYE) - (AssTXTVector[i].m_LYB + AssTXTVector[i].m_LYE))/2 - 
	//			   (AssTXTVector[i+1].m_LYE - AssTXTVector[i+1].m_LYB + AssTXTVector[i].m_LYE - AssTXTVector[i].m_LYB)/2;
	//		val3 = AssTXTVector[i].m_LH;

	//		if ( (val1 < val3*2) &&
	//			 (val2 < val3) )
	//		{
	//			if (AssTXTVector[i+1].m_LYE > AssTXTVector[i].m_LYE)
	//			{
	//				AssTXTVector[i].m_TXTStr = AssTXTVector[i].m_TXTStr + string("\\N") + AssTXTVector[i+1].m_TXTStr;
	//			}
	//			else
	//			{
	//				AssTXTVector[i].m_TXTStr = AssTXTVector[i+1].m_TXTStr + string("\\N") + AssTXTVector[i].m_TXTStr;
	//			}

	//			if (AssTXTVector[i].m_dX != -1)
	//			{
	//				val1 = ((AssTXTVector[i+1].m_LXB + AssTXTVector[i+1].m_LXE)/2 + (AssTXTVector[i].m_LXB + AssTXTVector[i].m_LXE)/2)/2;
	//				val2 = ((AssTXTVector[i+1].m_LYB + AssTXTVector[i+1].m_LYE)/2 + (AssTXTVector[i].m_LYB + AssTXTVector[i].m_LYE)/2)/2;

	//				AssTXTVector[i].m_dX = val1;
	//				AssTXTVector[i].m_dY = val2;
	//			}

	//			for(j=i+1; j<NT-1; j++)
	//			{
	//				AssTXTVector[j] = AssTXTVector[j+1];
	//			}
	//			NT--;
	//		}
	//		else
	//		{
	//			i = i;
	//		}
	//	}

	//	i++;
	//}

	//fout.open(string(g_work_dir + "/sub.ass").c_str(), ios::out);

	//fout << "Title: Default Aegisub file\n";
	//fout << "ScriptType: v4.00+\n";
	//fout << "PlayResX: " << W << "\n";
	//fout << "PlayResY: " << H << "\n";
	//fout << "PlayDepth: 16\n";
	//fout << "Timer: 100,0000\n";
	//fout << "WrapStyle: 1\n";
	//fout << "\n";
	//fout << "\n";
	//fout << "[V4+ Styles]\n";
	//fout << "Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n";

	//for(i=0; i<NS; i++)
	//{
	//	if (AssTXTStyleVector[i].m_MarginL == -1)
	//	{
	//		AssTXTStyleVector[i].m_MarginL = 10;
	//		AssTXTStyleVector[i].m_MarginR = 10;
	//	}

	//	YIQ_to_RGB( AssTXTStyleVector[i].m_mY, 
	//				AssTXTStyleVector[i].m_mI, 
	//				AssTXTStyleVector[i].m_mQ, 
	//				mR, mG, mB, 255 );

	//	sprintf(str, "&H00%.2X%.2X%.2X", mB, mG, mR);

	//	fout << "Style: " << AssTXTStyleVector[i].m_Name << ",";
	//	fout << "Arial Narrow," << AssTXTStyleVector[i].m_LH << ",";
	//	fout << str << ",";
	//	fout << "&H0000FFFF,&H00000000,&H80000000,-1,0,0,0,100,100,0,0,1,2,0,";
	//	fout << AssTXTStyleVector[i].m_Alignment << ",";
	//	fout << AssTXTStyleVector[i].m_MarginL << ",";
	//	fout << AssTXTStyleVector[i].m_MarginR << ",";
	//	fout << AssTXTStyleVector[i].m_MarginV << ",";
	//	fout << "204\n";
	//}

	//fout << "\n";
	//fout << "[Events]\n";
	//fout << "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text";

	//for(i=0; i<NT; i++)
	//{
	//	fout << "\n";

	//	fout << "Dialogue: 0,";
	//	fout << VideoTimeToStr3(AssTXTVector[i].m_BT) << ",";
	//	fout << VideoTimeToStr3(AssTXTVector[i].m_ET) << ",";
	//	fout << AssTXTVector[i].m_pAssStyle->m_Name << ",";
	//	fout << ",0000,0000,0000,,";

	//	if ( (AssTXTVector[i].m_Alignment != -1) ||
	//		 (AssTXTVector[i].m_dX != -1) )
	//	{
	//		fout << "{";

	//		if (AssTXTVector[i].m_Alignment != -1)
	//		{
	//			fout << "\\an" << AssTXTVector[i].m_Alignment;
	//		}

	//		if (AssTXTVector[i].m_dX != -1)
	//		{
	//			fout << "\\pos(" << AssTXTVector[i].m_dX << "," << AssTXTVector[i].m_dY << ")";
	//		}

	//		fout << "}";
	//	}

	//	fout << AssTXTVector[i].m_TXTStr;
	//}

	//fout.close();

	//delete[] AssTXTVector;
	//delete[] AssTXTStyleVector;
}

void COCRPanel::OnBnClickedCreateClearedTextImages(wxCommandEvent& event)
{
	if (g_IsCreateClearedTextImages == 0)
	{
		g_IsCreateClearedTextImages = 1;
		g_RunCreateClearedTextImages = 1;

		if (!(m_pMF->m_blnNoGUI))
		{
			m_pCCTI->SetLabel("Stop CCTXTImages");

			if (m_pMF->m_VIsOpen)
			{
				wxCommandEvent event;
				m_pMF->OnStop(event);

				m_pMF->m_VIsOpen = false;

				if (m_pMF->m_timer.IsRunning())
				{
					m_pMF->m_timer.Stop();
				}

				m_pMF->m_ct = -1;				

				m_pMF->m_pVideoBox->m_pVBar->ToggleTool(ID_TB_RUN, false);
				m_pMF->m_pVideoBox->m_pVBar->ToggleTool(ID_TB_PAUSE, false);
				m_pMF->m_pVideoBox->m_pVBar->ToggleTool(ID_TB_STOP, false);				
				m_pMF->m_pImageBox->ClearScreen();
				m_pMF->m_pVideo->SetNullRender();
			}

			m_pMF->m_pPanel->m_pSSPanel->Disable();
			m_pMF->m_pPanel->m_pSHPanel->Disable();
		}

		m_pSearchThread = new ThreadCreateClearedTextImages(m_pMF, m_pMF->m_blnNoGUI ? wxTHREAD_JOINABLE : wxTHREAD_DETACHED);
		m_pSearchThread->Create();
		m_pSearchThread->Run();
		//if (!(m_pMF->m_blnNoGUI)) m_pSearchThread->SetPriority(30); //THREAD_PRIORITY_BELOW_NORMAL
	}
	else
	{
		m_pMF->m_pPanel->m_pOCRPanel->Disable();
		g_RunCreateClearedTextImages = 0;
	}
}

ThreadCreateClearedTextImages::ThreadCreateClearedTextImages(CMainFrame *pMF, wxThreadKind kind)
        : wxThread(kind)
{
    m_pMF = pMF;
}

class FindTextLinesRes
{
public:
	int m_res;
	int m_w;
	int m_h;
	vector<wxString> m_SavedFiles;
	simple_buffer<int> m_ImRGB;
	simple_buffer<int> m_ImClearedText;
	custom_buffer<simple_buffer<int>> m_ImF;

	FindTextLinesRes()
	{
		m_res = 0;
	}
};

void FindTextLinesWithExcFilter(FindTextLinesRes *res)
{
	__try
	{
		res->m_res = FindTextLines(res->m_ImRGB, res->m_ImClearedText, res->m_ImF[5], res->m_ImF[3], res->m_ImF[1], res->m_ImF[0], res->m_SavedFiles, res->m_w, res->m_h);
	}
	__except (exception_filter(GetExceptionCode(), GetExceptionInformation(), "got error in FindTextLinesWithExcFilter"))
	{
		int j = 2;
	}
}

void FindTextLines(wxString FileName, FindTextLinesRes &res)
{
	try
	{
		wxString Str;
		int w, h;

		GetImageSize(string(FileName), w, h);
		res.m_w = w;
		res.m_h = h;
		res.m_ImRGB = simple_buffer<int>(w*h, 0);
		res.m_ImClearedText = simple_buffer<int>(w*h, 0);
		res.m_ImF = custom_buffer<simple_buffer<int>>(6, simple_buffer<int>(w*h, 0));

		LoadRGBImage(res.m_ImRGB, string(FileName), w, h);

		res.m_res = GetTransformedImage(res.m_ImRGB, res.m_ImF[3], res.m_ImF[4], res.m_ImF[5], res.m_ImF[1], res.m_ImF[2], w, h, w, h);

		if (g_show_transformed_images_only)
		{
			Str = FileName;
			Str = GetFileName(Str);
			Str = "/TXTImages/" + Str + g_im_save_format;
			SaveGreyscaleImage(res.m_ImF[5], string(Str), w, h);
			res.m_ImClearedText = res.m_ImF[5];
			return;
		}

		if (g_use_ISA_images_for_get_txt_area)
		{
			Str = FileName;
			Str = GetFileName(Str);
			Str = g_work_dir + "/ISAImages/" + Str + g_im_save_format;

			if (wxFileExists(Str))
			{
				LoadGreyscaleImage(res.m_ImF[5], string(Str), w, h);				
				if (g_show_results) SaveGreyscaleImage(res.m_ImF[5], "/TestImages/ThreadCreateClearedTextImages_01_ISAImage" + g_im_save_format, w, h);
				RestoreStillExistLines(res.m_ImF[5], res.m_ImF[3], w, h);
				ExtendImFWithDataFromImNF(res.m_ImF[5], res.m_ImF[3], w, h);
				if (g_show_results) SaveGreyscaleImage(res.m_ImF[5], "/TestImages/ThreadCreateClearedTextImages_02_ISAImageExtImNF" + g_im_save_format, w, h);
			}
		}

		// IL image
		res.m_ImF[0][0] = -1;
		if (g_use_ILA_images_for_get_txt_area)
		{
			Str = FileName;
			Str = GetFileName(Str);
			Str = g_work_dir + "/ILAImages/" + Str + g_im_save_format;

			if (wxFileExists(Str))
			{
				LoadGreyscaleImage(res.m_ImF[0], string(Str), w, h);
				if (g_show_results) SaveGreyscaleImage(res.m_ImF[0], "/TestImages/ThreadCreateClearedTextImages_03_ILAImage" + g_im_save_format, w, h);

				if (g_show_results) SaveGreyscaleImage(res.m_ImF[5], "/TestImages/ThreadCreateClearedTextImages_04_ISAImage" + g_im_save_format, w, h);
				IntersectTwoImages(res.m_ImF[5], res.m_ImF[0], w, h);
				if (g_show_results) SaveGreyscaleImage(res.m_ImF[5], "/TestImages/ThreadCreateClearedTextImages_05_ISAImageIntILAImage" + g_im_save_format, w, h);

				if (g_show_results) SaveGreyscaleImage(res.m_ImF[3], "/TestImages/ThreadCreateClearedTextImages_06_ImNF" + g_im_save_format, w, h);
				IntersectTwoImages(res.m_ImF[3], res.m_ImF[0], w, h);
				if (g_show_results) SaveGreyscaleImage(res.m_ImF[3], "/TestImages/ThreadCreateClearedTextImages_07_ImNFIntILAImage" + g_im_save_format, w, h);
			}
		}		

		Str = GetFileName(FileName);
		res.m_SavedFiles.push_back(Str);

		FindTextLinesWithExcFilter(&res);
	}
	catch (const exception& e)
	{
		g_pMF->SaveError(string("Got C++ Exception: got error in FindTextLines: ") + e.what());
	}
}

struct find_text_queue_data
{
	wxString m_file_name;
	FindTextLinesRes* m_p_res;
	my_event* m_p_event;
	bool m_is_end = false;
};

concurrency::task<void> TaskFindTextLines(concurrency::concurrent_queue<find_text_queue_data> &task_queue)
{
	return concurrency::create_task([&task_queue] {
			find_text_queue_data text_queue_data;

			while (1)
			{			
				if (task_queue.try_pop(text_queue_data))
				{
					if (text_queue_data.m_is_end)
					{
						break;
					}
					else
					{
						custom_set_started(text_queue_data.m_p_event);

						if (g_RunCreateClearedTextImages == 0)
						{
							text_queue_data.m_p_event->m_need_to_skip = true;
						}
						else
						{
							FindTextLines(g_work_dir + "/RGBImages/" + text_queue_data.m_file_name, *text_queue_data.m_p_res);
							text_queue_data.m_p_res->m_ImF.set_size(0);							
						}

						text_queue_data.m_p_event->set();
					}
				}
			}
		}
	);
}

void *ThreadCreateClearedTextImages::Entry()
{
	g_IsCreateClearedTextImages = 1;

	wxString Str, dStr;
	string fname;
	ofstream fout;
	char str[30];
	int i, j, k, xmin, xmax, ymin, ymax, val;
	
	int w1, h1, w2, h2, YB1, YB2, bln;
	wxString hour1, hour2, min1, min2, sec1, sec2, msec1, msec2;
	u64 bt1, et1, bt2, et2;

	int res;	

	if (g_clear_txt_folders)
	{
		m_pMF->ClearDir(g_work_dir + "/TXTImages");
		m_pMF->ClearDir(g_work_dir + "/TXTResults");
	}

	wxDir dir(g_work_dir + "/RGBImages");
	vector<wxString> FileNamesVector;
	vector<wxString> prevSavedFiles;
	vector<u64> BT, ET;
	wxString filename;
	bool bres;

	bres = dir.GetFirst(&filename);
    while ( bres )
    {
		FileNamesVector.push_back(filename);

        bres = dir.GetNext(&filename);
    }

	for (i=0; i<(int)FileNamesVector.size()-1; i++)
	for (j=i+1; j<(int)FileNamesVector.size(); j++)
	{
		if (FileNamesVector[i] > FileNamesVector[j])
		{
			Str = FileNamesVector[i];
			FileNamesVector[i] = FileNamesVector[j];
			FileNamesVector[j] = Str;
		}
	}

	__int64 t1, dt, num_calls;

	//t1 = GetTickCount();	

	if (g_clear_test_images_folder) m_pMF->ClearDir(g_work_dir + "/TestImages");
		
	int NImages = FileNamesVector.size();

	concurrency::concurrent_queue<find_text_queue_data> task_queue;
	simple_buffer<FindTextLinesRes*> task_results(NImages);
	simple_buffer<my_event*> task_events(NImages);
	vector<concurrency::task<void>> tasks(g_ocr_threads, concurrency::create_task([] {}));

	for (k = 0; k < NImages; k++)
	{
		task_results[k] = new FindTextLinesRes();
		task_events[k] = new my_event();
		task_queue.push({ FileNamesVector[k], task_results[k], task_events[k] });
	}

	for (k = 0; k < g_ocr_threads; k++)
	{
		task_queue.push({ "", NULL, NULL, true });
		tasks[k] = TaskFindTextLines(task_queue);
	}

	clock_t start_time = clock();

	for (k = 0; k < NImages; k++)
	{
		try
		{
			task_events[k]->wait();			

			if (task_events[k]->m_need_to_skip)
			{
				delete task_events[k];
				delete task_results[k];
				continue;
			}

			FindTextLinesRes *p_task_res = task_results[k];

			res = p_task_res->m_res;
			g_pViewImage[0](p_task_res->m_ImRGB, p_task_res->m_w, p_task_res->m_h);
			g_pViewRGBImage(p_task_res->m_ImClearedText, p_task_res->m_w, p_task_res->m_h);						

			if (!(m_pMF->m_blnNoGUI))
			{
				clock_t cur_time = clock();
				double progress = ((double)(k + 1) / (double)NImages) * 100.0;

				clock_t run_time = cur_time - start_time;
				clock_t eta = (clock_t)((double)run_time * (100.0 - progress) / progress);

				static char str[200];
				snprintf(str, 200, "progress: %%%2.2f eta : %s run_time : %s   |   %.5d : %.5d   ", progress, m_pMF->ConvertClockTime(eta), m_pMF->ConvertClockTime(run_time), k + 1, NImages);

				m_pMF->m_pVideoBox->m_plblTIME->SetLabel(str);

				Str = FileNamesVector[k];
				Str = GetFileName(Str);			

				m_pMF->m_pVideoBox->m_plblVB->SetLabel("VideoBox \"" + Str + "\"");
			}

			if ((res == 0) && (g_DontDeleteUnrecognizedImages1 == true))
			{
				Str = FileNamesVector[k];
				Str = GetFileName(Str);
				Str = wxString("/TXTImages/") + Str + wxString("_00001") + g_im_save_format;

				int color, wc;
				u8 *pClr;
				pClr = (u8*)(&color);
				color = 0;
				pClr[0] = 255;
				pClr[1] = 255;
				pClr[2] = 255;
				wc = color;

				simple_buffer<int> ImRES1((int)(p_task_res->m_w * g_scale)*(int)(p_task_res->m_h / g_scale), wc);
				SaveGreyscaleImage(ImRES1, string(Str), p_task_res->m_w*g_scale, p_task_res->m_h / g_scale);
			}
			/*
			if ( (k>1) && (res == 1) && (g_ValidateAndCompareTXTImages == true) && (prevSavedFiles.size() == task_res.m_SavedFiles.size()) )
			{
				Str = prevSavedFiles[i].c_str();
				i = Str.length()-1;
				while ((Str[i] != '\\') && (Str[i] != '/')) i--;
				Str = Str.Mid(i+1);

				hour1 = Str.Mid(0,1);
				min1 = Str.Mid(2,2);
				sec1 = Str.Mid(5,2);
				msec1 = Str.Mid(8,3);

				hour2 = Str.Mid(13,1);
				min2 = Str.Mid(15,2);
				sec2 = Str.Mid(18,2);
				msec2 = Str.Mid(21,3);

				bt1 = (atoi(hour1)*3600 + atoi(min1)*60 + atoi(sec1))*1000 + atoi(msec1);
				et1 = (atoi(hour2)*3600 + atoi(min2)*60 + atoi(sec2))*1000 + atoi(msec2);

				Str = task_res.m_SavedFiles[i].c_str();
				i = Str.length()-1;
				while ((Str[i] != '\\') && (Str[i] != '/')) i--;
				Str = Str.Mid(i+1);

				hour1 = Str.Mid(0,1);
				min1 = Str.Mid(2,2);
				sec1 = Str.Mid(5,2);
				msec1 = Str.Mid(8,3);

				hour2 = Str.Mid(13,1);
				min2 = Str.Mid(15,2);
				sec2 = Str.Mid(18,2);
				msec2 = Str.Mid(21,3);

				bt2 = (atoi(hour1)*3600 + atoi(min1)*60 + atoi(sec1))*1000 + atoi(msec1);
				et2 = (atoi(hour2)*3600 + atoi(min2)*60 + atoi(sec2))*1000 + atoi(msec2);

				if (bt2-et1 < 300)
				{
					bln = 1;
					for (i=0; i<(int)task_res.m_SavedFiles.size(); i++)
					{
						simple_buffer<int> ImRES1(task_res.m_w*task_res.m_h, 0);
						simple_buffer<int> ImRES2(task_res.m_w*task_res.m_h, 0);

						LoadGreyscaleImage(ImRES1, prevSavedFiles[i], w1, h1);
						LoadGreyscaleImage(ImRES2, task_res.m_SavedFiles[i], w2, h2);

						Str = prevSavedFiles[i].c_str();
						i = Str.length()-1;
						while (Str[i] != '_') i--;
						j = i;
						i--;
						while (Str[i] != '_') i--;
						Str = Str.Mid(i+1, j-i-1);
						YB1 = atoi(Str);

						Str = task_res.m_SavedFiles[i].c_str();
						i = Str.length()-1;
						while (Str[i] != '_') i--;
						j = i;
						i--;
						while (Str[i] != '_') i--;
						Str = Str.Mid(i+1, j-i-1);
						YB2 = atoi(Str);

						bln = CompareTXTImages(ImRES1, ImRES2, w1, h1, w2, h2, YB1, YB2);
						if (bln == 0) break;
					}

					if (bln == 1)
					{
						for (i=0; i<(int)task_res.m_SavedFiles.size(); i++)
						{
							DeleteFile(wxString(prevSavedFiles[i].c_str()));

							Str = prevSavedFiles[i].c_str();
							i = Str.length()-1;
							while ((Str[i] != '\\') && (Str[i] != '/')) i--;
							Str = Str.Mid(0,i+1+11)+wxString(task_res.m_SavedFiles[i].c_str()).Mid(i+1+11);

							MoveFile(wxString(task_res.m_SavedFiles[i].c_str()), Str);
						}
					}
				}
			}
			*/

			delete task_events[k];
			delete task_results[k];

			prevSavedFiles = p_task_res->m_SavedFiles;
		}
		catch (const exception& e)
		{
			g_pMF->SaveError(string("Got C++ Exception: got error in ThreadCreateClearedTextImages: ") + e.what());
		}
	}

	concurrency::when_all(begin(tasks), end(tasks)).wait();

	//(void)wxMessageBox("dt: " + std::to_string(GetTickCount() - t1));

	if (!(m_pMF->m_blnNoGUI))
	{
		m_pMF->m_pVideoBox->m_plblTIME->SetLabel("00:00:00,000/00:00:00,000   ");
		m_pMF->m_pPanel->m_pOCRPanel->m_pCCTI->SetLabel("Create Cleared TXT Images");

		m_pMF->m_pPanel->m_pSHPanel->Enable();
		m_pMF->m_pPanel->m_pSSPanel->Enable();		
		m_pMF->m_pPanel->m_pOCRPanel->Enable();
	}

	g_IsCreateClearedTextImages = 0;
	
	return 0;
}
